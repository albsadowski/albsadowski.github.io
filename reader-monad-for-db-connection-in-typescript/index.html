<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="albert's blog"><link rel="shortcut icon" href=https://albsadowski.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://albsadowski.github.io/reader-monad-for-db-connection-in-typescript/><title>Reader Monad for DB Connection in TypeScript</title></head><body><header id=banner><h2><a href=https://albsadowski.github.io/>albert's blog</a></h2><nav><ul><li><a href=/ title=posts>posts</a></li><li><a href=/research/ title=research>research</a></li><li><a href=/about/ title=about>about</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Reader Monad for DB Connection in TypeScript</h1><div><time>May 29, 2023</time></div></header><h2 id=mvcs>MVC(S)</h2><p>The <em>Model-View-Controller</em> is usually a standard pattern for building web applications. Whether the <em>view</em> is expressed as HTML or perhaps just plain JSON, it helps to structure the application in an elegant way.</p><p>The <em>Model</em> is a set of components responsible for representing the persistence layer, often in the form of some ORM classes. <em>View</em> maintains the recipe for generating the <em>view</em> given the <em>model</em>. Finally <em>controller</em> glues both parts together and deals with the other problems inherent in web development, such as parsing and interpreting query parameters.</p><p>Where does the business logic live? As long as the application is trivial, the <em>model</em> representation, combined with the power of ORMs, provides a powerful tool for manifesting the business domain. Then, the actual logic, either leaks to the <em>controller</em> or requires another component in the MVC pattern.</p><p>The <em>service</em> could be one of these components. The <em>service</em> sits between the <em>controller</em> and the <em>model</em>, either by contructing higher level <em>model</em> objects (non-ORM), or by simply enriching the ORM objects with an additional computation.</p><h2 id=acid>ACID</h2><p>As the application grows, the <em>services</em> become complex, often forming a hierarchy. Assuming there&rsquo;s still a database-backed <em>model</em> under the hood, all the <em>services</em> do is run a sequence of database queries to either read or mutate the state of the system.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>controllerMethod() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>service1</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>service2</span>(<span style=color:#a6e22e>res1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How can we ensure that a <em>controller</em> calling one or more <em>services</em>, maintains the <em>transation</em> boundary? We need to make all the components aware of the current state of the transaction. The current transaction state is usually just an instance of a <em>database connection</em>. And that&rsquo;s the moment where an implementation <em>detail</em> of the <em>model</em> brutally leaks through the MVC(S) stack.</p><p>If you want to make a <em>service</em> transactional, it should accept a <em>database connection</em> as a parameter on every method of a <em>service</em>. This is inconvenient and tightly couples all of the web application code to a chosen database (+ probably a chosen ORM/similar).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>controllerMethod() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tr</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>dbPool</span>.<span style=color:#a6e22e>transact</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>service1</span>(<span style=color:#a6e22e>tr</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>service2</span>(<span style=color:#a6e22e>tr</span>, <span style=color:#a6e22e>res1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>commit</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res2</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>rollback</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Another way to solve this problem via the state of the <em>request</em> - but the problem is equivalent - now we either inject the <em>request</em> or couple application code with a chosen web framework.</p><p>The approach suggested in this blog post is the <em>monad way</em>.</p><h2 id=the-monad-way>The Monad Way</h2><p>The <a href=https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html><em>Reader monad</em></a> is a well known pattern in the <em>Haskell</em> community to solve the problem of a shared <em>environment</em> between several components of the system.</p><p>The idea is quite simple:</p><ol><li>do not require the <em>environment</em> until you actually need it,</li><li>use <em>monad</em> properties to compose functions that depends on the <em>environment</em>.</li></ol><p>In our case, the <em>environment</em> is a database connection - either raw connection, or a transaction.</p><p>Point (1) above, is easier said than done, but in practice we can describe the whole computation process as a chain of lazily evaluated functions. Then, the final artefact should be a function that actually executes the program given the <em>environment</em> (database connection).</p><p>For <em>TypeScript</em> I have extracted the boilerplate into <a href=https://github.com/albsadowski/dbaction><em>DBAction</em></a> library, an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>controllerMethod() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>service1</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>flatMap</span>(<span style=color:#a6e22e>res</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>service2</span>(<span style=color:#a6e22e>res</span>))
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>transact</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>transactor</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s break this down:</p><h3 id=dbaction>DBAction</h3><p><em>DBAction</em> is an actual <em>reader monad</em> for the database connection. What services return is not a <code>Promise&lt;Result></code> type (a <em>promise</em> of some kind of result), but <code>DBAction&lt;Result></code>. After the service is called <code>this.service1()</code>, nothing happens until we either <code>run</code> or <code>transact</code> the <code>DBAction</code>. The value is referentially transparent, so if you call <code>this.service1</code> with the same input, you&rsquo;ll always get the same result.</p><p>The cost of this approach, is that all the components involved in the chain, must return <em>DBActions</em>. On the implementation side, this means that the moment you actually need the database connection, you should wrap it in a function that takes <em>database connection</em> as its only argument and returns a <em>promise</em> of some result type, e.g.:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>service1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>DBAction</span>((<span style=color:#a6e22e>conn</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>query</span>(<span style=color:#e6db74>&#34;select...&#34;</span>))
</span></span></code></pre></div><p>There are two methods available on the <em>DBAction</em> that should help composing the monad:</p><ol><li><code>.map&lt;K>(fn: (item: T) => K)</code> - mapping inner value into another value,</li><li><code>.flatMap&lt;K>(fn: (item: T) => DBAction&lt;K>)</code> - mapping inner value into another value, where the <code>fn</code> function also require the <em>database connection</em> for the computation.</li></ol><p>The <em>DBAction</em> can be:</p><ol><li><code>.run(tr: Transactor): Promise&lt;T></code> - meaning the transactor will inject plain database connection into the chain,</li><li><code>.transact(tr: Transactor): Promise&lt;T></code> - the transactor will start the transaction and then inject the connection into the chain, finally <em>commit</em> or <em>rollback</em>.</li></ol><h3 id=transactor>Transactor</h3><p>The <em>transactor</em> is a component that knows:</p><ol><li>the type of the database connection,</li><li>the details of establishing the database connection, or requesting the connection from the pool,</li><li>the details of executing the query and/or managing the transaction context.</li></ol><p>The <em>transactor</em> is database specific and depends on the database driver. There should be a single transactor for the entire application.</p><p>As of now, <em>DBAction</em> offers the one for <em>PostgreSQL</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Transactor</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;@dumpstate/dbaction/lib/PG&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// `pool` - an instance of `pg` connection pool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tr</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Transactor</span>(<span style=color:#a6e22e>pool</span>)
</span></span></code></pre></div><h3 id=utilities>Utilities</h3><p>The utilities available in the library, useful for composing the monad:</p><ol><li><code>flatten</code> - tranforms an array of <code>DBAction</code>s into a <code>DBAction</code> of an array of values,</li><li><code>pure</code> - wraps a scalar / promise / function returning a promise with a <code>DBAction</code> - useful to lift non-<em>DBAction</em> into a <em>DBAction</em>.</li><li><code>chain</code> - builds a sequential chain of <em>DBActions</em> - result of a previous is an argument for the latter,</li><li><code>sequence</code> - runs operations concurrently; returns a single <code>DBAction</code>,</li><li><code>query</code> - creates a <em>DBAction</em> for a query string.</li></ol><h2 id=links>Links</h2><ol><li><a href=https://github.com/albsadowski/dbaction><em>DBAction</em> GitHub Repository</a>.</li><li><a href=https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html><em>Reader Monad</em></a>.</li><li>Heavily inspired by <a href=https://tpolecat.github.io/doobie/><em>doobie</em></a>.</li></ol></article></main><footer id=footer>Copyright © 2025 Albert Sadowski</footer></body></html>