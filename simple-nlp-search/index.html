<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="albert's blog"><link rel="shortcut icon" href=https://dumpstate.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://dumpstate.github.io/simple-nlp-search/><title>Simple NLP Search</title></head><body><header id=banner><h2><a href=https://dumpstate.github.io>albert's blog</a></h2><nav><ul><li><a href=/ title=posts>posts</a></li><li><a href=/about/ title=about>about</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Simple NLP Search</h1><div><time>May 5, 2016</time></div></header><p>Full text search is easy to use. But the inherent ambiguity of natural languages
causes search results to be biased with false positives. To obtain more accurate results, we need to change the approach and provide more domain specific data to the search engine.</p><p>The most common and easiest to improve search results is to introduce filters, i.e. multiple input fields (text fields, radio buttons etc.) named after properties. This way we know how to shape the query and then return specific results. In combination with some approximate string matching algorithms, we may obtain very accurate search results. Unfortunately filters require forms with multiple fields at the cost of simple UX. (see <em>Figure 1</em>).</p><p><img src=./ebay-motors.png alt="Figure 1"></p><p>What if we&rsquo;d like to stick to a single text field and still have accurate search results (see <em>Figure 2</em>)? Surely one needs to employ natural language processing (NLP) tools. But everyone in the IT industry knows that NLP is hard to master and majority thinks it&rsquo;s a highly academic approach. How can this be easily employed to improve search results over a specific domain?</p><p><img src=./featured-image.png alt="Figure 2"></p><h2 id=domain>Domain</h2><p>Specificity of the domain is the key part of the approach. Machine learning algorithms are far from being ready to answer general questions. Even though the algorithms exist, they are far from our reach. For simplicity, we have to narrow the domain. Usually when we are in a need for introducing a search form, we operate within some area, i.e. finding a car at ebay.com we specify the type of the car, year of production, manufacturer, model etc..</p><p>For the sake of this article, let&rsquo;s take the domain of film screenings, i.e. tuple of: movie, theater and the date and time. We may also assume we know the geographical location of the theater and genre of the movie. We are going to query the film screening by title (or just genre), theater name (or just location) and date and time that the screening is going to happen - that is the data we need to collect from the user. Sample expressions we&rsquo;d like to handle:</p><ul><li><em>the martian in san francisco tomorrow</em> - query all theaters in San Francisco that will play <em>The Martian</em> tomorrow,</li><li><em>the revenant in amc next week</em> - query <em>AMC</em> theater for all shows of <em>The Revenant</em> that will occur next week,</li><li><em>cinemark next wednesday</em> - query <em>Cinemark</em> theaters for all the shows that will occur next Wednesday,</li><li><em>drama in san francisco on 11 June</em> - query all theaters in San Francisco for a drama that will occur on 11th of June.</li></ul><p>All expressions are transformed from natural language to a query of the form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Query</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  movie<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Either</span><span style=color:#f92672>[</span><span style=color:#66d9ef>MovieName</span>, <span style=color:#66d9ef>MovieGenre</span><span style=color:#f92672>]],</span>
</span></span><span style=display:flex><span>  theater<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Either</span><span style=color:#f92672>[</span><span style=color:#66d9ef>TheaterName</span>, <span style=color:#66d9ef>TheaterLocation</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span>  from<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>DateTime</span><span style=color:#f92672>],</span>
</span></span><span style=display:flex><span>  to<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>DateTime</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MovieName</span><span style=color:#f92672>(</span>value<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MovieGenre</span><span style=color:#f92672>(</span>value<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TheaterName</span><span style=color:#f92672>(</span>value<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TheaterLocation</span><span style=color:#f92672>(</span>value<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><h2 id=need-for-nlp>Need for NLP</h2><p>It is hard to extract information from natural language. If we assume that there are just a few kinds of input statements, like <code>[MOVIE_NAME] in [THEATER_LOCATION] [TIME_EXPRESSION]</code>, then it might be possible to program the parser for such statements explicitly. But even though someone manages to do this, such an algorithm would be unmaintainable. With NLP tools we may approach this problem without the need to program explicitly.</p><p>Moreover, some statements are extremely similar in their structure, e.g.: <code>[MOVIE_NAME] [TIME_EXPRESSION]</code> and <code>[THEATER_NAME] [TIME_EXPRESSION]</code> - it is impossible to unambiguously differentiate both statements. NLP tools also care about the structure of <code>[MOVIE_NAME]</code> and <code>[THEATER NAME]</code>, then when extracting the information from statements it has more data to make a decision than the explicit parser.</p><h2 id=description-of-the-solution>Description of the solution</h2><p>For our example the only subtask of information extraction we need is called <em>named entity recognition</em>. Having the statement properly tagged we are able to compose our <code>Query</code>. By tagging we mean assigning some domain specific meta information to each word from the statement, e.g.:</p><ul><li><em>the martian in san francisco tomorrow</em> -> <em>(MOVIE_NAME: the martian) (PREPOSITION: in) (THEATER_LOCATION: san francisco) (TIME_EXPRESSION: tomorrow)</em></li><li><em>amc next wednesday</em> -> <em>(THEATER_NAME: amc) (TIME_EXPRESSION: next wednesday)</em></li></ul><h3 id=tools>Tools</h3><p>When trying to tackle the problem, our first attempt was to try the <a href=http://nlp.stanford.edu/software/CRF-NER.shtml>Stanford Named Entity Recognizer</a>, which gave us stunning results, but unfortunately cannot be used commercially because of the GNU GPLv2 licensing.</p><p>Finally we decided to use the <a href=https://github.com/dlwh/epic>Epic</a> library from <a href=http://www.scalanlp.org/>ScalaNLP</a> suite (all licensed under Apache 2.0). <em>Epic</em> has many NLP algorithms implemented, but the downside we encountered is lack of the documentation thus it&rsquo;s usage is far from straightforward.</p><h3 id=sample-data>Sample data</h3><p>In order to train the Named Entity Recognizer (NER) we need to supply the algorithm with sample data. If we don&rsquo;t have any real life data then we may generate some random statements based on possible schemas, like:</p><ul><li><code>[MOVIE_NAME] in [THEATER_LOCATION] [TIME_EXPRESSION]</code></li><li><code>[MOVIE_GENRE] [TIME_EXPRESSION] in [THEATER_LOCATION]</code></li></ul><p>The format of the input depends on the library we use. The academic standard for describing the training data, <a href=http://www.cnts.ua.ac.be/conll2003/ner/>CoNLL</a>, covers much more than we need. Fortunately there is a way to simplify to just tagging, i.e.:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>the MOVIE_NAME
</span></span><span style=display:flex><span>martian MOVIE_NAME
</span></span><span style=display:flex><span>in PREPOSITION
</span></span><span style=display:flex><span>san THEATER_LOCATION
</span></span><span style=display:flex><span>francisco THEATER_LOCATION
</span></span><span style=display:flex><span>tomorrow TIME_EXPRESSION
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>comedy MOVIE_GENRE
</span></span><span style=display:flex><span>thursday TIME_EXPRESSION
</span></span><span style=display:flex><span>evening TIME_EXPRESSION
</span></span><span style=display:flex><span>in PREPOSITION
</span></span><span style=display:flex><span>san THEATER_LOCATION
</span></span><span style=display:flex><span>francisco THEATER_LOCATION
</span></span></code></pre></div><p>The optimal size of the training sample depends on the complexity of the domain and should be verified empirically.</p><p>You can check the example at <a href=https://github.com/evojam/simple-nlp-search-dataset-generator>GitHub</a> how we generated sample data.</p><h3 id=training-ner>Training NER</h3><p>We need to encode the relationships between the tagged statements and then construct some consistent interpretations for further reuse. Statistical tools that solves this problem are called <em>conditional random fields (CRFs)</em>. In <em>ScalaNLP</em> there are two implementations of CRF available. The first one <code>epic.sequences.CRF</code> is the ordinary linear-chain CRF and the second one <code>epic.sequences.SemiCRF</code> is an implementation of semi-Markov linear chain that should have better performance at small cost of accuracy.</p><h4 id=load-input-data-into-sequence-reader>Load input data into sequence reader</h4><p><em>ScalaNLP</em> has built-in parser for CoNLL data - <code>epic.corpora.CONLLSequenceReader</code> which accepts the data input we proposed in section <em>Sample data</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>var</span> sequenceReader <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>CONLLSequenceReader</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>.</span>readTrain<span style=color:#f92672>(</span>dataSetInputStream<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>.</span>toIndexedSeq
</span></span></code></pre></div><h4 id=apply-segmentation-function>Apply segmentation function</h4><p>We train the CRF by transforming the input data to <code>epic.sequences.Segmentation[Any, String]</code>. The segmentation is grouping the same tags in a row.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>val</span> seq <span style=color:#66d9ef>=</span> sequenceReader<span style=color:#f92672>.</span>map<span style=color:#f92672>(</span>segmentation<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>the segmentation function we use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>def</span> segmentation<span style=color:#f92672>(</span>ex<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Example</span><span style=color:#f92672>[</span><span style=color:#66d9ef>IndexedSeq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]</span>, <span style=color:#66d9ef>IndexedSeq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>IndexedSeq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Segmentation</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Any</span>, <span style=color:#66d9ef>String</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> segments <span style=color:#66d9ef>=</span> ex<span style=color:#f92672>.</span>label<span style=color:#f92672>.</span>foldLeft<span style=color:#f92672>(</span><span style=color:#a6e22e>List</span><span style=color:#f92672>.</span>empty<span style=color:#f92672>[(</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span><span style=color:#f92672>)]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>acc<span style=color:#f92672>,</span> label<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> acc <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> head <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>tail</span> <span style=color:#f92672>=&gt;</span> head <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>`label`<span style=color:#f92672>,</span> beg<span style=color:#f92672>,</span> end<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>label<span style=color:#f92672>,</span> beg<span style=color:#f92672>,</span> end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>tail</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>nextLabel<span style=color:#f92672>,</span> beg<span style=color:#f92672>,</span> end<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>label<span style=color:#f92672>,</span> end<span style=color:#f92672>,</span> end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>head</span> <span style=color:#66d9ef>::</span> <span style=color:#66d9ef>tail</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Nil</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>((</span><span style=color:#a6e22e>String</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> segmentsSeq <span style=color:#66d9ef>=</span> segments
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>reverse<span style=color:#f92672>.</span>map <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>label<span style=color:#f92672>,</span> beg<span style=color:#f92672>,</span> end<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>label<span style=color:#f92672>,</span> <span style=color:#a6e22e>Span</span><span style=color:#f92672>(</span>beg<span style=color:#f92672>,</span> end<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>toIndexedSeq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Segmentation</span><span style=color:#f92672>(</span>segmentsSeq<span style=color:#f92672>,</span> ex<span style=color:#f92672>.</span>features<span style=color:#f92672>.</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>mkString<span style=color:#f92672>),</span> ex<span style=color:#f92672>.</span>id<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=build-crf>Build CRF</h4><p>having the input segmented, we can build the CRF:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>val</span> crf <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>SemiCRF</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>.</span>buildSimple<span style=color:#f92672>(</span>seq<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>.</span>asInstanceOf<span style=color:#f92672>[</span><span style=color:#66d9ef>SemiCRF</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>String</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><h4 id=use-the-trained-crf-for-tagging-sequences>Use the trained <code>crf</code> for tagging sequences</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>val</span> taggedSequence<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Segmentation</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>String</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
</span></span><span style=display:flex><span>crf<span style=color:#f92672>.</span>bestSequence<span style=color:#f92672>(</span>epic<span style=color:#f92672>.</span>preprocess<span style=color:#f92672>.</span>tokenize<span style=color:#f92672>(</span>inputString<span style=color:#f92672>))</span>
</span></span></code></pre></div><p><code>epic.preprocess.tokenize</code> is just tokenizing by whitespace.</p><p>The <code>Segmentation</code> carries the tagged sequence. When we render a sample expression we get a string with tagged segments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>[MOVIE_NAME: the martian] [PREPOSITION: in] [THEATER_LOCATION: san francisco] [PREPOSITION: on] [TIME_EXPRESSION: 11th June 2016]
</span></span></code></pre></div><p>With such a tagging we are almost ready to construct the <code>Query</code>. The only missing part are the <code>TIME_EXPRESSION</code>s. We need explicit <code>from</code> and <code>to</code> parameters of type <code>DateTime</code>. We may use <a href=http://www.ocpsoft.org/prettytime/nlp/>PrettyTime::NLP</a> to parse explicit time expressions, like: <code>11th June 2016</code>, but if we want to obtain something more sophisticated, like <code>next Wed</code> or <code>tomorrow</code> we should employ the NLP approach again, i.e. training the CRF for time expressions.</p><p>The results are pretty astonishing. The <code>crf</code>, once trained, is working instantly. The accuracy of the interpretation will vary depending on the complexity of the domain and size of the training sample. In our case, we were surprised about the accuracy - even for ambiguous statements, the <code>crf</code> was doing well.</p><p>For the sample size of 200K input statements (generated with <a href=https://github.com/evojam/simple-nlp-search-dataset-generator>simple-ner-search-dataset-generator</a>, we&rsquo;ve trained the NER with <a href=https://github.com/evojam/ner-trainer>ner-trainer</a>, and get the following results:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>the martian in san francisco tomorrow
</span></span><span style=display:flex><span>[MOVIE_NAME: the martian] [PREPOSITION: in] [THEATER_LOCATION: san francisco] [TIME_EXPRESSION: tomorrow] (in 8 ms)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>the revenant in amc next week
</span></span><span style=display:flex><span>[MOVIE_NAME: the revenant] [PREPOSITION: in] [THEATER_NAME: amc] [TIME_EXPRESSION: next week] (in 15 ms)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cinemark next wednesday
</span></span><span style=display:flex><span>[THEATER_NAME: cinemark] [TIME_EXPRESSION: next wednesday] (in 2 ms)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>drama in san francisco on 11 june
</span></span><span style=display:flex><span>[MOVIE_GENRE: drama] [PREPOSITION: in] [THEATER_LOCATION: san francisco] [PREPOSITION: on] [TIME_EXPRESSION: 11 june] (in 4 ms)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>amc next wednesday
</span></span><span style=display:flex><span>[THEATER_NAME: amc] [TIME_EXPRESSION: next wednesday] (in 2 ms)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>the martian in san francisco on 11th june 2016
</span></span><span style=display:flex><span>[MOVIE_NAME: the martian] [PREPOSITION: in] [THEATER_LOCATION: san francisco] [PREPOSITION: on] [TIME_EXPRESSION: 11th june 2016] (in 8 ms)
</span></span></code></pre></div><p>You can check this yourself in the interactive session by installing the <a href=https://github.com/evojam/ner-trainer>ner-trainer</a> and loading the serialized <a href="https://www.dropbox.com/s/qfezeynlcegkfni/film-screenings.tar.gz?dl=0">example</a> by calling <code>ner-trainer -l film-screenings.tar.gz</code>.</p><h3 id=tradeoffs>Tradeoffs</h3><p>Unfortunately training the <em>CRF</em> is extremely time consuming (measured in hours). There is a need to serialize the <code>SemiCRF</code> object in order not to waste time. The serialization comes at the cost of taking care of binary compatibility. Also <code>SemiCRF</code> might be a quite heavy object, so there comes the cost of additional memory.</p><p>The <em>Epic</em> library is not easy to use. The documentation is not very helpful, and also lacks serious static typing. Even in this short example we were not able to avoid <code>asInstanceOf</code>.</p><h2 id=conclusions>Conclusions</h2><p>The libraries that are currently available nicely cover the hard parts of the problem. The tradeoffs are possible to overcome and many of them are relatively easy to fix, so probably will disappear in the future. Nevertheless it is possible to construct quite sophisticated NLP based search without drowning in complicated math. Even the newcomer should be able to implement the search in a matter of days.</p><h3 id=urls>URLs</h3><ul><li>ScalaNLP: <a href=http://www.scalanlp.org/>http://www.scalanlp.org/</a></li><li>Stanford Named Entity Recognizer: <a href=http://nlp.stanford.edu/software/CRF-NER.shtml>http://nlp.stanford.edu/software/CRF-NER.shtml</a></li><li>PrettyTime::NLP: <a href=http://www.ocpsoft.org/prettytime/nlp/>http://www.ocpsoft.org/prettytime/nlp/</a></li><li>NER Trainer: <a href=https://github.com/evojam/ner-trainer>https://github.com/evojam/ner-trainer</a></li><li>Film Screenings Data Set Generator: <a href=https://github.com/evojam/simple-nlp-search-dataset-generator>https://github.com/evojam/simple-nlp-search-dataset-generator</a></li><li>Sample <a href="https://drive.google.com/file/d/0ByjmxsRtyWkLMWwxT2cyamJ1WUU/view?usp=sharing">serialized CRF for film screenings</a></li></ul><p>All of you feel invited to checkout and hack with NER trainer and data set generator on your domain. Please provide feedback in comments how this approach is working for you.</p><p>This article was originally published on <a href=http://tech.evojam.com>tech.evojam.com</a> – there are many other interesting posts there!</p></article></main><footer id=footer>Copyright © 2023 Albert Sadowski</footer></body></html>